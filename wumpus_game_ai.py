# -*- coding: utf-8 -*-
"""2205233_wumpus_game_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bYE4sJDGWFKV-A0MSHt2bGbJz6Cs7lLk
"""

!apt-get install -y xvfb python-opengl > /dev/null 2>&1
!pip install pygame imageio ipywidgets > /dev/null 2>&1
import os
import pygame
import random
import time
import imageio
from collections import deque
from IPython.display import display, Image

# Setup for Colab
os.environ["SDL_VIDEODRIVER"] = "dummy"

# Initialize Pygame
pygame.init()
pygame.font.init()

# Constants
WIDTH, HEIGHT = 600, 600
GRID_SIZE = 10
CELL_SIZE = WIDTH // GRID_SIZE
BACKGROUND_COLOR = (30, 30, 30)
AI_PATH_COLOR = (0, 255, 0)
START_COLOR = (0, 0, 255)
END_COLOR = (255, 0, 0)
WUMPUS_COLOR = (255, 0, 255)
PIT_COLOR = (139, 69, 19)
GOLD_COLOR = (255, 215, 0)
AGENT_COLOR = (0, 255, 255)
GLITTER_COLOR = (255, 255, 0)
STENCH_COLOR = (200, 0, 0)
BREEZE_COLOR = (135, 206, 250)

DIRECTIONS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

def generate_positions():
    start = (0, 0)
    gold = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))
    wumpus = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))
    pits = []
    for i in range(GRID_SIZE):
        for j in range(GRID_SIZE):
            if (i, j) != start and (i, j) != gold and (i, j) != wumpus and random.random() < 0.15:
                pits.append((i, j))
    return start, gold, wumpus, pits

def get_sensory_indicators(gold, wumpus, pits):
    glitter, stench, breeze = set(), set(), set()
    glitter.add(gold)
    for dx, dy in DIRECTIONS:
        neighbor = (wumpus[0] + dx, wumpus[1] + dy)
        if 0 <= neighbor[0] < GRID_SIZE and 0 <= neighbor[1] < GRID_SIZE:
            stench.add(neighbor)
    for pit in pits:
        for dx, dy in DIRECTIONS:
            neighbor = (pit[0] + dx, pit[1] + dy)
            if 0 <= neighbor[0] < GRID_SIZE and 0 <= neighbor[1] < GRID_SIZE:
                breeze.add(neighbor)
    return glitter, stench, breeze

def bfs_smart_search(start, gold, wumpus, pits, stench, breeze, glitter):
    queue = deque([(start, [start])])
    visited = set([start])
    last_safe_path = None

    while queue:
        current, path = queue.popleft()
        if current == gold:
            return path
        last_safe_path = path  # Save the last explored safe path
        for dx, dy in DIRECTIONS:
            neighbor = (current[0] + dx, current[1] + dy)
            if 0 <= neighbor[0] < GRID_SIZE and 0 <= neighbor[1] < GRID_SIZE and neighbor not in visited:
                if neighbor in stench or neighbor in breeze:
                    continue  # Avoid dangerous areas
                if neighbor in glitter:
                    return path + [neighbor]  # Move immediately to gold if detected
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    return last_safe_path  # Return the farthest safe path explored

class WumpusGame:
    def __init__(self):
        self.screen = pygame.Surface((WIDTH, HEIGHT))
        self.start, self.gold, self.wumpus, self.pits = generate_positions()
        self.glitter, self.stench, self.breeze = get_sensory_indicators(self.gold, self.wumpus, self.pits)
        self.path = None
        self.frames = []
        self.font = pygame.font.SysFont('Arial', 16)

    def draw_grid(self):
        self.screen.fill(BACKGROUND_COLOR)
        for x in range(0, WIDTH, CELL_SIZE):
            pygame.draw.line(self.screen, (100, 100, 100), (x, 0), (x, HEIGHT))
        for y in range(0, HEIGHT, CELL_SIZE):
            pygame.draw.line(self.screen, (100, 100, 100), (0, y), (WIDTH, y))

    def draw_elements(self):
        for pit in self.pits:
            pygame.draw.rect(self.screen, PIT_COLOR, (pit[1] * CELL_SIZE, pit[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))
        pygame.draw.rect(self.screen, WUMPUS_COLOR, (self.wumpus[1] * CELL_SIZE, self.wumpus[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))
        pygame.draw.rect(self.screen, GOLD_COLOR, (self.gold[1] * CELL_SIZE, self.gold[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))
        for pos in self.glitter:
            pygame.draw.circle(self.screen, GLITTER_COLOR, (pos[1] * CELL_SIZE + CELL_SIZE//2, pos[0] * CELL_SIZE + CELL_SIZE//2), 5)
        for pos in self.stench:
            pygame.draw.circle(self.screen, STENCH_COLOR, (pos[1] * CELL_SIZE + CELL_SIZE//2, pos[0] * CELL_SIZE + CELL_SIZE//2), 5)
        for pos in self.breeze:
            pygame.draw.circle(self.screen, BREEZE_COLOR, (pos[1] * CELL_SIZE + CELL_SIZE//2, pos[0] * CELL_SIZE + CELL_SIZE//2), 5)

    def capture_frame(self):
        pygame.image.save(self.screen, "temp_frame.png")
        self.frames.append(imageio.imread("temp_frame.png"))
        os.remove("temp_frame.png")

    def play_game(self):
        print("Starting Wumpus World AI...")
        self.path = bfs_smart_search(self.start, self.gold, self.wumpus, self.pits, self.stench, self.breeze, self.glitter)
        if self.path:
            print(f"Path found with {len(self.path)} steps!")
        else:
            print("No valid path found. Displaying last explored safe path.")

        for pos in self.path or []:
            self.draw_grid()
            self.draw_elements()
            pygame.draw.rect(self.screen, AGENT_COLOR, (pos[1] * CELL_SIZE, pos[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))
            self.capture_frame()
            time.sleep(0.3)
        imageio.mimsave("wumpus_search.gif", self.frames, duration=0.5, loop=0)
        display(Image(filename="wumpus_search.gif"))

# Run the game
game = WumpusGame()
game.play_game()

import zipfile
from google.colab import files

with zipfile.ZipFile('2205233_wumpus_game_ai.zip', 'w') as zipf:
    zipf.write('2205233_wumpus_game_ai.py', arcname='2205233_wumpus_game_ai.py')

files.download('2205233_wumpus_game_ai.zip')